<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Stary Bird</title>
<meta name="theme-color" content="#0a0f17">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<style>
  :root { color-scheme: light dark; }
  html, body { margin:0; padding:0; height:100%; background:#07090d; color:#eaf2ff;
    font:14px/1.5 system-ui, Segoe UI, Roboto, Arial, sans-serif; }
  body { overflow:hidden; overscroll-behavior:none; touch-action:none;
    -webkit-user-select:none; -webkit-touch-callout:none; }
  .stage { position:fixed; inset:0; width:100vw; height:100svh; background:transparent; }
  #game  { position:absolute; inset:0; width:100%; height:100%; display:block;
           background:linear-gradient(180deg,#0a1120,#0a0f17 65%, #090d14); touch-action:none; }
  .hud{ position:absolute; right:calc(12px + env(safe-area-inset-right));
        top:calc(12px + env(safe-area-inset-top)); background:rgba(255,255,255,.08);
        padding:6px 10px; border-radius:10px; font-weight:800; letter-spacing:.06em; z-index:3; }
  .controls{ position:absolute; left:calc(12px + env(safe-area-inset-left));
             top:calc(12px + env(safe-area-inset-top)); opacity:.6; font-weight:700;
             color:#c9d8ff; z-index:2; }
  .center{ position:absolute; inset:0; display:grid; place-items:center; pointer-events:none;
           font-weight:900; letter-spacing:.08em; color:#9fb7ff99; text-align:center; padding:0 10px; z-index:1; }
  .toast{ position:fixed; left:50%; top:12px; transform:translateX(-50%);
          background:#2a1620; color:#ffd5dc; border:1px solid #572238; padding:8px 12px;
          border-radius:10px; font-weight:700; letter-spacing:.02em; box-shadow:0 12px 24px rgba(0,0,0,.4);
          z-index:9999; opacity:0; transition:opacity .15s ease; }
  .toast.show{ opacity:1; }
</style>
</head>
<body>
  <div class="stage">
    <canvas id="game" aria-label="Stary Bird game canvas"></canvas>
    <div class="hud" id="hud">0 • HI 0</div>
    <div class="controls" aria-hidden="true">SPACE / TAP</div>
    <div class="center" id="msg">TAP / SPACE TO START</div>
  </div>
  <div id="toast" class="toast" role="status" aria-live="polite"></div>

<script>
(() => {
  'use strict';

  /* =========================
     DOM & CTX
  ========================== */
  const canvas = document.getElementById('game');
  const ctx    = canvas.getContext('2d', { alpha: true });
  const hud    = document.getElementById('hud');
  const msg    = document.getElementById('msg');
  const toastEl= document.getElementById('toast');

  /* =========================
     ENV / SETTINGS
  ========================== */
  const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || (window.innerWidth < 900);

  const SETTINGS = {
    speedBase: isMobile ? 3.6 : 4.2,
    speedMax:  isMobile ? 8.2 : 8.8,
    accelEarly: 0.00025,
    accelMain:  0.00060,
    gapStart: 150,
    gapMin: 132,
    gapShrinkPerMs: 0.0035,
    maxSlopePxPerSec: 240,
    movingProb: 0.14,
    doubleProb: 0.10,
    doubleSpacing: 130,
    movingAmpMax: 24,
    respawnDelayMs: 1000,
    pipeW: 70,
    margin: 60
  };

  /* =========================
     TOOLS / HELPERS
  ========================== */
  const rand  = (a,b)=> Math.random()*(b-a)+a;
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const now   = () => performance.now();

  function makeImg(src) {
    const img = new Image();
    img.decoding = 'async';
    img.loading = 'eager';
    img.src = src;
    img.onerror = () => { img._error = true; console.warn('[Image failed]', src); showToast('Image not found: ' + src); };
    img.onload  = () => { if (!img.naturalWidth) { img._error = true; showToast('Bad image: ' + src); } };
    return img;
  }

  function showToast(text){
    if (!toastEl) return;
    toastEl.textContent = text;
    toastEl.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toastEl.classList.remove('show'), 2000);
  }

  // Glow sprite
  function makeGlowSprite(size = 256, tint = [170, 200, 255]) {
    const off = document.createElement('canvas');
    off.width = off.height = size;
    const c = off.getContext('2d');
    const g = c.createRadialGradient(size/2, size/2, size*0.08, size/2, size/2, size*0.48);
    g.addColorStop(0.00, 'rgba(255,255,255,0.70)');
    g.addColorStop(0.35, `rgba(${tint[0]},${tint[1]},${tint[2]},0.35)`);
    g.addColorStop(0.75, `rgba(${tint[0]},${tint[1]},${tint[2]},0.10)`);
    g.addColorStop(1.00, 'rgba(0,0,0,0)');
    c.globalCompositeOperation = 'lighter';
    c.fillStyle = g;
    c.beginPath();
    c.arc(size/2, size/2, size*0.48, 0, Math.PI*2);
    c.fill();
    return off;
  }
  const glowSprite = makeGlowSprite();
  function drawGlow(ctx, x, y, r, alpha = 1) {
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = alpha;
    const d = r * 2;
    ctx.drawImage(glowSprite, x - r, y - r, d, d);
    ctx.restore();
  }

  /* =========================
     DPR / SIZING
  ========================== */
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function sizeToViewport() {
    const vv = window.visualViewport;
    const cssW = Math.floor(vv ? vv.width  : window.innerWidth);
    const cssH = Math.floor(vv ? vv.height : window.innerHeight);
    canvas.style.width  = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width  = Math.max(1, Math.floor(cssW * DPR));
    canvas.height = Math.max(1, Math.floor(cssH * DPR));
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  const ro = new ResizeObserver(() => {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    sizeToViewport();
  });
  ro.observe(document.documentElement);
  if (window.visualViewport) window.visualViewport.addEventListener('resize', sizeToViewport, {passive:true});
  window.addEventListener('orientationchange', () => setTimeout(sizeToViewport, 150), {passive:true});
  sizeToViewport();

  // Prevent double-tap zoom on iOS
  let lastTouchEnd = 0;
  document.addEventListener('touchend', e => {
    const t = Date.now();
    if (t - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = t;
  }, {passive:false});

  /* =========================
     ASSETS
  ========================== */
  const ghostImg = makeImg('assets/ghost.png'); // keep your existing ghost

  /* =========================
     STATE
  ========================== */
  const state = {
    playing:false, dead:false, score:0,
    hi:Number(localStorage.getItem('stary_bird_hi')||0),
    t:0, shake:0, flash:0,
    gravity:0.33, thrust:0.6, maxVy:9,
    speed: SETTINGS.speedBase, gap: SETTINGS.gapStart,
    spawn:0, minSpawnFrames:110, maxSpawnFrames:170,
    lastGapY:null, lastPipeX:null,
    orbs:[], pipes:[], particles:[],
    startTime:0, deathPause:false, deathTimer:0
  };

  const TRAIL = {
    base:'#cfe3ff', blue:'#4ab7ff', purple:'#b06cff', gold:'#ffd54a'
  };

  const player = { x:180, y:canvas.clientHeight/2, vy:0, rot:0, targetRot:0, hold:false, w:60, h:60 };

  /* =========================
     INPUT
  ========================== */
  function startIfNeeded(){
    if (!state.playing && !state.dead){ start(); }
    else if (state.dead && !state.deathPause){ restart(); }
  }
  function onKey(e, down){
    if (['Space','ArrowUp','KeyW','Enter'].includes(e.code)) {
      e.preventDefault();
      player.hold = down;
      if (down) startIfNeeded();
      else if (state.dead && !state.deathPause) restart();
    }
  }
  window.addEventListener('keydown', e => onKey(e,true), {passive:false});
  window.addEventListener('keyup',   e => onKey(e,false), {passive:false});
  canvas.addEventListener('touchstart', e => { e.preventDefault(); player.hold = true; startIfNeeded(); }, {passive:false});
  canvas.addEventListener('touchend',   e => { e.preventDefault(); player.hold = false; if (state.dead && !state.deathPause) restart(); }, {passive:false});

  /* =========================
     WORLD GEN
  ========================== */
  function currentGapY(pipe){
    if (pipe.type === 'moving'){
      return pipe.baseGapY + Math.sin(pipe.phase + state.t/1000 * pipe.speed)*pipe.amp;
    }
    return pipe.baseGapY;
  }

  function addPipe(){
    const h = canvas.clientHeight;

    // spawn cadence based on current speed
    const baseMin = state.minSpawnFrames * (4.2/state.speed);
    const baseMax = state.maxSpawnFrames * (4.2/state.speed);
    state.spawn = Math.floor(rand(baseMin, baseMax));
    const timeToNext = state.spawn * (16.67 / 1000);

    const mid = h/2;
    const prev = state.lastGapY ?? mid;
    const safeTop = SETTINGS.margin + state.gap/2;
    const safeBot = h - SETTINGS.margin - state.gap/2;

    const allowedDelta = Math.min(SETTINGS.maxSlopePxPerSec * timeToNext, 170);
    const proposed = prev + rand(-allowedDelta, +allowedDelta) + rand(-8, 8);
    const gapY = clamp(proposed, safeTop, safeBot);

    const isMoving = Math.random() < SETTINGS.movingProb;
    const isDouble = !isMoving && Math.random() < SETTINGS.doubleProb;

    const maxAmpByGap = Math.max(0, (state.gap * 0.5) - 50);
    const amp = isMoving ? Math.min(rand(12, SETTINGS.movingAmpMax), maxAmpByGap) : 0;

    // primary pipe
    state.pipes.push({
      x: canvas.clientWidth + 40,
      baseGapY: gapY,
      w: SETTINGS.pipeW,
      passed:false,
      type: isMoving ? 'moving' : 'normal',
      amp, speed: isMoving ? rand(0.8, 1.2) : 0, phase: Math.random()*Math.PI*2,
      doubleGap:false
    });

    // occasional double
    if (isDouble){
      state.pipes.push({
        x: canvas.clientWidth + 40 + SETTINGS.pipeW + SETTINGS.doubleSpacing,
        baseGapY: clamp(gapY + rand(-24, 24), safeTop, safeBot),
        w: SETTINGS.pipeW, passed:false, type:'normal', amp:0, speed:0, phase:0, doubleGap:true
      });
    }

    state.lastGapY = gapY;
    state.lastPipeX = canvas.clientWidth + 40;

    // orb near gap
    if (Math.random() < 0.55){
      state.orbs.push({ x: canvas.clientWidth + 40 + SETTINGS.pipeW/2, y: gapY, r:8, taken:false, t0: state.t });
    }
  }

  /* =========================
     GAME FLOW
  ========================== */
  function reset(){
    state.playing=false; state.dead=false; state.deathPause=false; state.deathTimer=0;
    state.score=0;
    state.speed=SETTINGS.speedBase; state.gap=SETTINGS.gapStart; state.gravity=0.33; state.thrust=0.6;
    state.pipes.length=0; state.orbs.length=0; state.particles.length=0;
    state.spawn=30; state.t=0; state.shake=0; state.flash=0;
    state.lastGapY = canvas.clientHeight/2; state.lastPipeX = canvas.clientWidth;
    player.x=180; player.y=canvas.clientHeight/2; player.vy=0; player.rot=0; player.targetRot=0; player.hold=false;
    if (msg) { msg.textContent = 'TAP / SPACE TO START'; msg.style.display=''; }
  }

  function start(){
    if (state.dead || state.deathPause) return;
    state.playing=true;
    state.startTime = now();
    if (msg) msg.style.display = 'none';
  }

  function restart(){ reset(); start(); }

  function colorForScore(score){
    if (score >= 50) return TRAIL.gold;
    if (score >= 25) return TRAIL.purple;
    if (score >= 10) return TRAIL.blue;
    return TRAIL.base;
  }

  function addTrail(){
    const c = colorForScore(state.score);
    for (let i=0;i<3;i++){
      const life = Math.random()*14+24;
      state.particles.push({
        type:'spark',
        x: player.x - 26 + Math.random()*10,
        y: player.y + Math.random()*10 - 5,
        vx: -state.speed*0.6 + (Math.random()*-0.6),
        vy: (Math.random()-.5)*1.3,
        g: 0, spin:0, life, maxLife: life, r: Math.random()*2+2, color: c
      });
    }
  }

  function hitPipe(pipe){
    const gy = currentGapY(pipe);
    const half = ((pipe.doubleGap ? (state.gap - 6) : state.gap) / 2);
    if (player.x + player.w*0.35 > pipe.x && player.x - player.w*0.35 < pipe.x + pipe.w){
      if (player.y - player.h*0.35 < gy - half || player.y + player.h*0.35 > gy + half) return true;
    }
    return false;
  }
  const hitBounds = () => (player.y < 0) || (player.y > canvas.clientHeight);

  function explode(px, py){
    const trail = colorForScore(state.score);
    const skinColor = '#cfe3ff';
    for (let i=0;i<28;i++){
      const ang = Math.random()*Math.PI*2, spd = 2.2 + Math.random()*3.2, life = 24 + Math.random()*18;
      state.particles.push({ type:'spark', x:px, y:py, vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd,
        g: 0.08, spin:0, life, maxLife:life, r: 1.6 + Math.random()*2.2, color: (Math.random()<0.6 ? trail : '#9fe9ff') });
    }
    for (let i=0;i<16;i++){
      const ang = Math.random()*Math.PI*2, spd = 2.0 + Math.random()*3.8, life = 26 + Math.random()*22;
      state.particles.push({ type:'shard', x:px, y:py, vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd - 0.5,
        g: 0.12, spin: (Math.random()*0.3)*(Math.random()<0.5?1:-1), life, maxLife:life,
        w: 6 + Math.random()*6, h: 2 + Math.random()*3, rot: Math.random()*Math.PI, color: (Math.random()<0.5 ? skinColor : trail) });
    }
    state.shake = 10; state.flash = 0.5;
  }

  function die(){
    if (state.dead || state.deathPause) return;
    state.dead = true; state.playing = false;
    state.hi = Math.max(state.hi, state.score);
    try { localStorage.setItem('stary_bird_hi', String(state.hi)); } catch(e){}
    explode(player.x, player.y);
    state.deathPause = true;
    state.deathTimer = SETTINGS.respawnDelayMs;
    if (msg) msg.style.display = 'none';
  }

  /* =========================
     LOOP
  ========================== */
  let last = now();
  let rafId = 0;

  function step(t){
    const dt = Math.min(32, t - last); last = t;
    const step = dt / 16.67;
    state.t += dt;

    if (state.deathPause){
      tickParticles(step);
      state.shake *= 0.9; state.flash = Math.max(0, state.flash - 0.06);
      draw();
      rafId = requestAnimationFrame(step);
      state.deathTimer -= dt;
      if (state.deathTimer <= 0){ state.deathPause = false; reset(); }
      return;
    }

    if (state.playing && !state.dead){
      const sinceStart = Math.max(0, t - state.startTime);
      const accel = (sinceStart < 3000) ? SETTINGS.accelEarly : SETTINGS.accelMain;
      state.speed = Math.min(SETTINGS.speedMax, state.speed + accel * dt);
      state.gap   = Math.max(SETTINGS.gapMin, state.gap - SETTINGS.gapShrinkPerMs * dt);

      // input & physics
      if (player.hold){ player.vy -= state.thrust * step; addTrail(); }
      // soft attraction to orbs
      for (const o of state.orbs){
        if (o.taken) continue;
        const dx = player.x - o.x, dy = player.y - o.y, d2 = dx*dx + dy*dy;
        if (d2 < 100*100){
          const pull = 0.6 * step;
          player.vy += Math.max(-0.8*step, Math.min(0.8*step, (o.y - player.y) * pull / 100));
        }
      }

      player.vy += state.gravity * step;
      player.vy = Math.max(-9, Math.min(state.maxVy, player.vy));
      player.y  += player.vy * step;
      player.targetRot = Math.max(-0.8, Math.min(0.8, (-0.6) + ((player.vy+9)/18) * (0.8 - (-0.6))));
      player.rot += (player.targetRot - player.rot) * 0.2;

      // spawn / advance
      state.spawn -= step;
      if (state.spawn <= 0) addPipe();
      for (const pipe of state.pipes) pipe.x -= state.speed * step;
      for (const orb of state.orbs)  orb.x  -= state.speed * step;

      // scoring & collisions
      for (const pipe of state.pipes){
        if (!pipe.passed && player.x > pipe.x + pipe.w){ pipe.passed = true; state.score++; }
        if (hitPipe(pipe)) { die(); break; }
      }
      if (!state.dead && hitBounds()) die();

      tickParticles(step);

      // cull
      while (state.pipes.length && state.pipes[0].x + state.pipes[0].w < -40) state.pipes.shift();
      while (state.orbs.length && state.orbs[0].x + 20 < -40) state.orbs.shift();
    }

    state.shake *= 0.9; state.flash = Math.max(0, state.flash - 0.06);
    draw();
    rafId = requestAnimationFrame(step);
  }

  function tickParticles(step){
    for (const prt of state.particles){
      prt.vy += (prt.g||0) * step;
      prt.x  += prt.vx * step;
      prt.y  += prt.vy * step;
      if (prt.type==='shard'){ prt.rot = (prt.rot||0) + (prt.spin||0); }
      prt.life -= step;
    }
    while (state.particles.length && state.particles[0].life<=0) state.particles.shift();
  }

  /* =========================
     RENDER
  ========================== */
  function draw(){
    const sx = (Math.random()*2-1)*state.shake;
    const sy = (Math.random()*2-1)*state.shake;

    ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

    // parallax stars
    ctx.globalAlpha = 0.06;
    for (let i=0;i<70;i++){
      const x = (i*130 - (state.t*0.035)%130);
      const y = 30 + (i*47) % (canvas.clientHeight-60);
      ctx.fillStyle="#bcd1ff"; ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 0.12;
    for (let i=0;i<40;i++){
      const x = (i*220 - (state.t*0.06)%220);
      const y = 20 + ((i*83) % (canvas.clientHeight-40)) + Math.sin((state.t*0.0006)+i)*2;
      ctx.fillStyle="#e7f0ff"; ctx.fillRect(x, y, 3, 3);
    }
    ctx.globalAlpha = 1;

    ctx.save(); ctx.translate(sx, sy);

    // pipes (rect fallback; still looks clean)
    for (const pipe of state.pipes){
      const gy = currentGapY(pipe);
      const half = ((pipe.doubleGap ? (state.gap - 6) : state.gap) / 2);
      const x = pipe.x, w = pipe.w;
      const yTop = 0, hTop = gy - half;
      const yBot = gy + half, hBot = canvas.clientHeight - yBot;
      ctx.fillStyle = "#12324f";
      if (hTop>0) ctx.fillRect(x, yTop, w, hTop);
      if (hBot>0) ctx.fillRect(x, yBot, w, hBot);
      ctx.fillStyle = "#1a476f";
      if (hTop>0) ctx.fillRect(x, yTop+hTop-4, w, 4);
      if (hBot>0) ctx.fillRect(x, yBot, 4, 4);
    }

    // orbs
    for (const o of state.orbs){
      if (o.taken) continue;
      const pulse = 1 + 0.18*Math.sin(state.t/120 + o.x*0.02);
      const grd = ctx.createRadialGradient(o.x, o.y, 0, o.x, o.y, o.r*6*pulse);
      grd.addColorStop(0, 'rgba(119,234,255,0.35)');
      grd.addColorStop(1, 'rgba(119,234,255,0)');
      ctx.fillStyle = grd;
      ctx.beginPath(); ctx.arc(o.x, o.y, o.r*6*pulse, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(o.x, o.y, o.r*pulse, 0, Math.PI*2);
      ctx.fillStyle = "#77eaff"; ctx.fill();
      ctx.strokeStyle = "#c8f3ff"; ctx.lineWidth = 2; ctx.stroke();
    }

    // particles
    for (const prt of state.particles){
      const a = prt.maxLife ? Math.max(0, prt.life / prt.maxLife) : 0;
      if (a <= 0) continue;
      ctx.globalAlpha = a;
      ctx.fillStyle = prt.color;
      if (prt.type === 'shard'){
        ctx.save(); ctx.translate(prt.x, prt.y); ctx.rotate(prt.rot||0);
        ctx.fillRect(-(prt.w||6)/2, -(prt.h||3)/2, prt.w||6, prt.h||3);
        ctx.restore();
      } else {
        ctx.beginPath(); ctx.arc(prt.x, prt.y, prt.r||2, 0, Math.PI*2); ctx.fill();
      }
    }
    ctx.globalAlpha = 1;

    // player
    if (!state.dead && !state.deathPause){
      const flying   = state.playing && !state.dead;
      const baseHz   = 0.022;
      const speedMul = flying ? Math.min(2.2, 1 + Math.abs(player.vy)/6) : 1;
      const cycle    = state.t * baseHz * speedMul;
      const flap     = Math.sin(cycle * Math.PI * 2);
      const idleOffset = (!state.playing) ? Math.sin(state.t * 0.005) * 8 : 0;
      const sAmtVel  = Math.min(0.18, Math.max(0, Math.abs(player.vy)/12 * 0.15));
      const sAmtFlap = flying ? 0.12 : 0.05;
      const wiggle   = flying ? flap * 0.08 : flap * 0.04;

      ctx.save();
      ctx.translate(player.x, player.y + idleOffset);
      ctx.rotate(player.rot + wiggle);
      const sx = (1 + sAmtVel) * (1 + flap *  sAmtFlap);
      const sy = (1 - sAmtVel) * (1 - flap *  sAmtFlap);
      ctx.scale(sx, sy);

      const sz = 54;
      drawGlow(ctx, 0, 0, sz * 0.78, 0.95);

      if (!ghostImg._error){
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(ghostImg, -sz/2, -sz/2, sz, sz);
      } else {
        ctx.fillStyle = '#9fc2ff';
        ctx.beginPath(); ctx.arc(0,0, sz*0.45, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }

    ctx.restore();

    if (state.flash>0){
      ctx.fillStyle = `rgba(255,255,255,${state.flash*0.6})`;
      ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
    }

    hud.textContent = `${state.score} • HI ${state.hi}`;
  }

  /* =========================
     PAGE VISIBILITY (pause)
  ========================== */
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      cancelAnimationFrame(rafId);
      last = now(); // reset delta on resume
    } else {
      last = now();
      rafId = requestAnimationFrame(step);
    }
  });

  /* =========================
     BOOT
  ========================== */
  function boot(){
    reset();
    last = now();
    rafId = requestAnimationFrame(step);
  }
  boot();
})();
</script>
</body>
</html>
