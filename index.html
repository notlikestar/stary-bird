<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Stary Bird</title>
<meta name="theme-color" content="#0a0f17">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">

<!-- App icon (mobile & browsers) -->
<link rel="apple-touch-icon" sizes="512x512" href="assets/gameicon.png">
<link rel="icon" type="image/png" sizes="512x512" href="assets/gameicon.png">

<style>
  :root { color-scheme: light dark; }
  html, body {
    margin:0; padding:0; height:100%;
    background:#07090d; color:#eaf2ff;
    font:14px/1.5 system-ui, Segoe UI, Roboto, Arial, sans-serif;
  }
  body {
    overflow:hidden; overscroll-behavior:none; touch-action:none;
    -webkit-user-select:none; -webkit-touch-callout:none;
  }
  .stage { position:fixed; inset:0; width:100vw; height:100svh; background:transparent; }
  #game  { position:absolute; left:0; top:0; width:100%; height:100%; display:block;
           background:linear-gradient(180deg,#0a1120,#0a0f17 65%, #090d14); touch-action:none;
           will-change: transform; backface-visibility: hidden; }

  /* Force landscape presentation when the device is held in portrait */
  @media (orientation: portrait) {
    .stage{
      width:100vh;
      height:100vw;
      transform-origin: 0 0;
      /* translate first (in unrotated coords), then rotate 90deg */
      transform: translateY(-100vw) rotate(90deg);
    }
    /* HUD / controls already positioned absolutely on the stage, so they rotate with it */
  }

  .hud{
    position:absolute;
    right:calc(12px + env(safe-area-inset-right));
    top:  calc(12px + env(safe-area-inset-top));
    background:rgba(255,255,255,.08);
    padding:6px 10px; border-radius:10px;
    font-weight:800; letter-spacing:.06em; z-index:3;
  }
  .controls{
    position:absolute;
    left:calc(12px + env(safe-area-inset-left));
    top: calc(12px + env(safe-area-inset-top));
    opacity:.6; font-weight:700; color:#c9d8ff; z-index:2;
  }
  .center{ position:absolute; inset:0; display:grid; place-items:center;
           pointer-events:none; font-weight:900; letter-spacing:.08em;
           color:#9fb7ff99; text-align:center; padding:0 10px; z-index:1; }

  /* Toast */
  .toast{
    position:fixed; left:50%; top:12px; transform:translateX(-50%);
    background:#2a1620; color:#ffd5dc; border:1px solid #572238;
    padding:8px 12px; border-radius:10px; font-weight:700; letter-spacing:.02em;
    box-shadow:0 12px 24px rgba(0,0,0,.4);
    z-index:9999; opacity:0; transition:opacity .15s ease;
  }
  .toast.show{ opacity:1; }
</style>
</head>
<body>
  <div class="stage">
    <canvas id="game"></canvas>
    <div class="hud" id="hud">0 • HI 0</div>
    <div class="controls">SPACE / TAP</div>
    <div class="center" id="msg">TAP / SPACE TO START</div>
  </div>

  <!-- Toast container -->
  <div id="toast" class="toast" role="status" aria-live="polite"></div>

<script>
(() => {
  'use strict';

  /* ======= SINGLE SOURCE OF TRUTH FOR GRAVITY ======= */
  const GRAVITY = 0.33; // ← tweak this (lower = floatier, higher = heavier)

  /* ===== MOBILE-SAFE GLOW ===== */
  function makeGlowSprite(size = 256, tint = [170, 200, 255]) {
    const off = document.createElement('canvas');
    off.width = off.height = size;
    const c = off.getContext('2d');

    const g = c.createRadialGradient(size/2, size/2, size*0.08, size/2, size/2, size*0.48);
    g.addColorStop(0.00, 'rgba(255,255,255,0.70)');
    g.addColorStop(0.35, `rgba(${tint[0]},${tint[1]},${tint[2]},0.35)`);
    g.addColorStop(0.75, `rgba(${tint[0]},${tint[1]},${tint[2]},0.10)`);
    g.addColorStop(1.00, 'rgba(0,0,0,0)');

    c.globalCompositeOperation = 'lighter';
    c.fillStyle = g;
    c.beginPath();
    c.arc(size/2, size/2, size*0.48, 0, Math.PI*2);
    c.fill();
    return off;
  }
  const glowSprite = makeGlowSprite();

  function drawGlow(ctx, x, y, r, alpha = 1) {
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = alpha;
    const d = r * 2;
    ctx.drawImage(glowSprite, x - r, y - r, d, d);
    ctx.restore();
  }

  /* ==================== SMALL TOAST ==================== */
  const toastEl = document.getElementById('toast');
  let toastTimer = null;
  function showToast(msg){
    if (!toastEl) return;
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toastEl.classList.remove('show'), 2000);
  }

  /* ==================== CANVAS + UI ==================== */
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: true });
  const hud = document.getElementById('hud');
  const msg = document.getElementById('msg');

  /* ---------- Robust sizing (+ overscan to kill edge seams) ---------- */
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function sizeToViewport() {
    const vv = window.visualViewport;
    let w = Math.floor(vv ? vv.width  : window.innerWidth);
    let h = Math.floor(vv ? vv.height : window.innerHeight);

    /* If device is held in portrait, pretend the canvas' logical size is landscape
       (we rotate the stage in CSS), so swap w/h here. */
    if (h > w) { const tmp = w; w = h; h = tmp; }

    // Overscan by 2px and offset by -1px to hide 1px seams on mobile Safari when shaking/transforming.
    canvas.style.left  = '-1px';
    canvas.style.top   = '-1px';
    canvas.style.width  = (w + 2) + 'px';
    canvas.style.height = (h + 2) + 'px';

    const cw = Math.max(1, Math.floor((w + 2) * DPR));
    const ch = Math.max(1, Math.floor((h + 2) * DPR));
    canvas.width = cw; canvas.height = ch;
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  new ResizeObserver(() => { DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1)); sizeToViewport(); }).observe(document.body);
  window.addEventListener('orientationchange', () => setTimeout(sizeToViewport, 150), {passive:true});
  if (window.visualViewport) window.visualViewport.addEventListener('resize', sizeToViewport, {passive:true});
  sizeToViewport();

  // Prevent double-tap zoom on iOS
  let lastTouchEnd = 0;
  document.addEventListener('touchend', e => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = now;
  }, {passive:false});

  /* ----------------------- Images ----------------------- */
  function makeImg(src) {
    const img = new Image();
    img.decoding = 'async';
    img.loading = 'eager';
    img.src = src;
    img.onerror = () => { img._error = true; console.warn('[Image failed]', src); showToast('Image not found: ' + src); };
    img.onload = () => {
      if (!img.naturalWidth) { img._error = true; console.warn('[Bad image: width=0]', src); showToast('Bad image: ' + src); }
      else { console.log('[Image OK]', src, img.naturalWidth + 'x' + img.naturalHeight); }
    };
    return img;
  }
  const ghostImg = makeImg('assets/ghost.png');

  // sleeve assets (exact sizes: body 40x100, cuffs 40x60)
  const sleeveBodyImg   = makeImg('assets/sleevebody.png');       // 40x100
  const sleeveCuffTop   = makeImg('assets/sleevecufftop.png');    // 40x60 (faces down)
  const sleeveCuffBottom= makeImg('assets/sleevecuffbottom.png'); // 40x60 (faces up)

  // orb image (load once)
  const orbImg = makeImg('assets/star.png');

  let PIPE_W = 40;  // exact width used for sleeves
  let BODY_H = 100; // sleeve body tile height
  let CUFF_H = 60;  // cuff height
  let PIPE_SCALE = 0.85; // ← make sleeves a bit smaller

  sleeveBodyImg.onload = () => {
    if (sleeveBodyImg.naturalWidth) {
      PIPE_W = sleeveBodyImg.naturalWidth;
      BODY_H = sleeveBodyImg.naturalHeight;
    }
  };
  function syncCuffDims(img){
    if (img && img.naturalWidth) {
      PIPE_W = img.naturalWidth;
      CUFF_H = img.naturalHeight;
      for (const pp of state.pipes) {
        const cx = pp.x + pp.w/2;
        pp.w = Math.round(PIPE_W * PIPE_SCALE);
        pp.x = Math.round(cx - pp.w/2);
      }
    }
  }
  sleeveCuffTop.onload = () => syncCuffDims(sleeveCuffTop);
  sleeveCuffBottom.onload = () => syncCuffDims(sleeveCuffBottom);

  /* ----------------------- Helpers ----------------------- */
  const rand  = (a,b)=> Math.random()*(b-a)+a;
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));

  const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || (window.innerWidth < 900);

  const SETTINGS = {
    speedBase: isMobile ? 3.6 : 4.2,
    speedMax:  isMobile ? 8.2 : 8.8,
    accelEarly: 0.00025,
    accelMain:  0.00060,
    gapMin: 132,
    gapShrinkPerMs: 0.0035,
    maxSlopePxPerSec: 240,
    movingProb: 0.14,
    doubleProb: 0.00,            // ← remove double sleeves
    doubleSpacing: 130,
    movingAmpMax: 24,
    respawnDelayMs: 1000
  };

  /* ----------------------- Game State ----------------------- */
  const state = {
    playing:false, dead:false, score:0, hi:Number(localStorage.getItem('stary_bird_hi')||0),
    t:0, shake:0, flash:0,
    gravity: GRAVITY, thrust:0.6, maxVy:9,
    speed: SETTINGS.speedBase, gap:150,
    spawn:0, minSpawnFrames:110, maxSpawnFrames:170,
    maxSlopePxPerFrame:2.4, lastGapY:null, lastPipeX:null,
    orbs:[], pipes:[],

    // TRAIL (simple bursts)
    trailDots:[],

    // particles kept for explosions only
    particles:[],

    // Trail color progression (grey → blue → purple → red/orange)
    trailBase:'#9aa0a6',    // grey
    trailBlue:'#4ab7ff',    // blue
    trailPurple:'#b06cff',  // purple
    trailGold:'#ff6a00',    // red/orange

    startTime:0,
    elapsed:0,
    deathPause:false,
    deathTimer:0
  };

  const p = { x:180, y:canvas.clientHeight/2, vy:0, rot:0, targetRot:0, hold:false, w:60, h:60 };

  /* ----------------------- Input ----------------------- */
  function startIfNeeded(){
    if (!state.playing && !state.dead){
      start();
    } else if (state.dead && !state.deathPause){
      restart();
    }
  }
  window.addEventListener('keydown', e => {
    if (['Space','ArrowUp','KeyW','Enter'].includes(e.code)) {
      e.preventDefault(); p.hold = true; startIfNeeded();
    }
  }, {passive:false});
  window.addEventListener('keyup', e => {
    if (['Space','ArrowUp','KeyW','Enter'].includes(e.code)) {
      e.preventDefault(); p.hold = false;
      if (state.dead && !state.deathPause) restart();
    }
  }, {passive:false});
  canvas.addEventListener('touchstart', e => { e.preventDefault(); p.hold = true; startIfNeeded(); }, {passive:false});
  canvas.addEventListener('touchend',   e => { e.preventDefault(); p.hold = false; if (state.dead && !state.deathPause) restart(); }, {passive:false});

  /* ----------------------- World ----------------------- */
  function addPipe(){
    const h = canvas.clientHeight, margin = 60;

    const baseMin = state.minSpawnFrames * (4.2/state.speed);
    const baseMax = state.maxSpawnFrames * (4.2/state.speed);
    state.spawn = Math.floor(rand(baseMin, baseMax));
    const timeToNext = state.spawn * (16.67 / 1000);

    const mid = h/2;
    const prev = state.lastGapY ?? mid;
    const safeTop = margin + state.gap/2;
    const safeBot = h - margin - state.gap/2;

    const allowedDelta = Math.min(SETTINGS.maxSlopePxPerSec * timeToNext, 170);
    let proposed = prev + rand(-allowedDelta, +allowedDelta);

    const wobble = rand(-8, 8);
    const gapY = clamp(proposed + wobble, safeTop, safeBot);

    const w = Math.round(PIPE_W * PIPE_SCALE); // ← thinner sleeves

    const isMoving = Math.random() < SETTINGS.movingProb;
    const isDouble = false; // SETTINGS.doubleProb is 0, but be explicit

    const maxAmpByGap = Math.max(0, (state.gap * 0.5) - 50);
    const amp = isMoving ? Math.min(rand(12, SETTINGS.movingAmpMax), maxAmpByGap) : 0;

    state.pipes.push({
      x: canvas.clientWidth + 40,
      baseGapY: gapY,
      w,
      passed:false,
      type: isMoving ? 'moving' : 'normal',
      amp,
      speed: isMoving ? rand(0.8, 1.2) : 0,
      phase: Math.random()*Math.PI*2,
      doubleGap:false
    });

    if (isDouble){
      state.pipes.push({
        x: canvas.clientWidth + 40 + w + SETTINGS.doubleSpacing,
        baseGapY: clamp(gapY + rand(-24, 24), safeTop, safeBot),
        w,
        passed:false,
        type:'normal',
        amp:0, speed:0, phase:0,
        doubleGap:true
      });
    }

    state.lastGapY = gapY;
    state.lastPipeX = canvas.clientWidth + 40;

    if (Math.random() < 0.55){
      state.orbs.push({ x: canvas.clientWidth + 40 + w/2, y: gapY, r:8, taken:false, t0: state.t });
    }
  }

  const currentGapY = (pipe) => {
    if (pipe.type === 'moving'){
      return pipe.baseGapY + Math.sin(pipe.phase + state.t/1000 * pipe.speed)*pipe.amp;
    }
    return pipe.baseGapY;
  };

  /* ----------------------- Flow ----------------------- */
  function reset(){
    state.playing=false; state.dead=false;
    state.deathPause=false; state.deathTimer=0;
    state.score=0;
    state.speed=SETTINGS.speedBase; state.gap=150; state.gravity=GRAVITY; state.thrust=0.6;
    state.pipes.length=0; state.orbs.length=0; state.particles.length=0; state.trailDots.length=0;
    state.spawn=30; state.t=0; state.elapsed=0; state.shake=0; state.flash=0;
    state.lastGapY = canvas.clientHeight/2; state.lastPipeX = canvas.clientWidth;
    p.x=180; p.y=canvas.clientHeight/2; p.vy=0; p.rot=0; p.targetRot=0; p.hold=false;

    if (msg) { msg.textContent = 'TAP / SPACE TO START'; msg.style.display=''; }
    updateUI();
  }
  function start(){
    if (state.dead || state.deathPause) return;
    state.playing=true;
    state.startTime = performance.now();
    state.elapsed = 0;
    if (msg) msg.style.display = 'none';
    updateUI();
  }
  function restart(){ reset(); start(); }

  function updateUI(){
    // no-op for now
  }

  /* ----------------------- Trail (SIMPLE BURST) ----------------------- */
  function colorForScore(score){
    if (score >= 50) return state.trailGold;   // red/orange
    if (score >= 25) return state.trailPurple; // purple
    if (score >= 10) return state.trailBlue;   // blue
    return state.trailBase;                    // grey
  }
  function progressionLevel(score){
    if (score >= 50) return 3; // red/orange
    if (score >= 25) return 2; // purple
    if (score >= 10) return 1; // blue
    return 0;                  // grey
  }

  // Create a compact radial burst behind the ghost (expands + fades)
  function addTrail(){
    const lvl = progressionLevel(state.score);
    const baseR   = [4, 6,8,10][lvl];   // start radius
    const maxR    = [18,20,22,23][lvl];  // end radius
    const glows   = [14,18,22,23][lvl];  // ↑ stronger glow per level
    const life    = 16 + Math.random()*6;

    state.trailDots.push({
      x: p.x - 10, y: p.y + Math.random()*2-1,
      w: baseR,
      len: maxR,
      glow: glows,
      ang: 0,
      color: colorForScore(state.score),
      life, maxLife: life,
      seed: Math.random()*1000,
      lvl
    });

    if (state.trailDots.length > 120) state.trailDots.splice(0, state.trailDots.length - 120);
  }

  /* ----------------------- Collisions ----------------------- */
  function hitPipe(pipe){
    const gy = currentGapY(pipe);
    const half = ((pipe.doubleGap ? (state.gap - 6) : state.gap) / 2);
    if (p.x + p.w*0.35 > pipe.x && p.x - p.w*0.35 < pipe.x + pipe.w){
      if (p.y - p.h*0.35 < gy - half || p.y + p.h*0.35 > gy + half) return true;
    }
    return false;
  }
  function hitBounds(){ return (p.y < 0) || (p.y > canvas.clientHeight); }

  /* ----------------------- Explosion ----------------------- */
  function explode(px, py){
    const trail = colorForScore(state.score);
    let skinColor = '#cfe3ff';

    for (let i=0;i<28;i++){
      const ang = Math.random()*Math.PI*2;
      const spd = 2.2 + Math.random()*3.2;
      const life = 24 + Math.random()*18;
      state.particles.push({
        type:'spark',
        x:px, y:py,
        vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd,
        g: 0.08, spin:0,
        life, maxLife:life,
        r: 1.6 + Math.random()*2.2,
        color: (Math.random()<0.6 ? trail : '#9fe9ff')
      });
    }
    for (let i=0;i<16;i++){
      const ang = Math.random()*Math.PI*2;
      const spd = 2.0 + Math.random()*3.8;
      const life = 26 + Math.random()*22;
      state.particles.push({
        type:'shard',
        x:px, y:py,
        vx: Math.cos(ang)*spd, vy: Math.sin(ang)*spd - 0.5,
        g: 0.12, spin: (Math.random()*0.3)*(Math.random()<0.5?1:-1),
        life, maxLife:life,
        w: 6 + Math.random()*6, h: 2 + Math.random()*3,
        rot: Math.random()*Math.PI,
        color: (Math.random()<0.5 ? skinColor : trail)
      });
    }
    state.shake = 10;
    state.flash = 0.5;
  }

  /* -------- Sleeve rendering (replaces pipes with your assets) -------- */
  function drawTopPipeSection(ctx, x, yTop, w, hTop) {
    if (hTop <= 0 || !sleeveBodyImg || !sleeveCuffTop) return;

    ctx.imageSmoothingEnabled = false;

    const tileW = PIPE_W;
    x = Math.round(x); yTop = Math.round(yTop);

    const cuffDrawH = Math.min(CUFF_H, hTop);
    const cuffSrcY  = CUFF_H - cuffDrawH;
    const cuffDestY = yTop + hTop - cuffDrawH;
    ctx.drawImage(sleeveCuffTop, 0, cuffSrcY, tileW, cuffDrawH, x, cuffDestY, w, cuffDrawH);

    let remaining = hTop - cuffDrawH;
    let y = cuffDestY;
    while (remaining > 0) {
      const sliceH = Math.min(BODY_H, remaining);
      ctx.drawImage(
        sleeveBodyImg,
        0, BODY_H - sliceH, tileW, sliceH,
        x, y - sliceH, w, sliceH
      );
      y -= sliceH;
      remaining -= sliceH;
    }
  }

  function drawBottomPipeSection(ctx, x, yBot, w, hBot) {
    if (hBot <= 0 || !sleeveBodyImg || !sleeveCuffBottom) return;

    ctx.imageSmoothingEnabled = false;

    const tileW = PIPE_W;
    x = Math.round(x); yBot = Math.round(yBot);

    const cuffDrawH = Math.min(CUFF_H, hBot);
    ctx.drawImage(sleeveCuffBottom, 0, 0, tileW, cuffDrawH, x, yBot, w, cuffDrawH);

    let remaining = hBot - cuffDrawH;
    let y = yBot + cuffDrawH;
    while (remaining > 0) {
      const sliceH = Math.min(BODY_H, remaining);
      ctx.drawImage(
        sleeveBodyImg,
        0, 0, tileW, sliceH,
        x, y, w, sliceH
      );
      y += sliceH;
      remaining -= sliceH;
    }
  }

  /* ==================== Fixed 60 FPS Update ==================== */
  const FIXED_DT = 1000/60;     // ~16.6667ms
  const MAX_STEPS = 5;          // cap to avoid spiral of death
  let lastTime = performance.now();
  let accumulator = 0;

  function tick(dtMs){
    state.t += dtMs;
    const step = dtMs / 16.67;

    if (state.deathPause){
      state.deathTimer -= dtMs;

      // decay bursts & particles during pause too
      for (const d of state.trailDots) { d.life -= step; }
      while (state.trailDots.length && state.trailDots[0].life<=0) state.trailDots.shift();

      for (const prt of state.particles){
        prt.vy += (prt.g||0) * step;
        prt.x  += prt.vx * step;
        prt.y  += prt.vy * step;
        if (prt.type==='shard'){ prt.rot = (prt.rot||0) + (prt.spin||0); }
        prt.life -= step;
      }
      while (state.particles.length && state.particles[0].life<=0) state.particles.shift();

      state.shake *= 0.9; state.flash = Math.max(0, state.flash - 0.06);

      if (state.deathTimer <= 0){
        state.deathPause = false;
        reset();
      }
      return;
    }

    if (state.playing && !state.dead){
      state.elapsed += dtMs;
      const accel = (state.elapsed < 3000) ? SETTINGS.accelEarly : SETTINGS.accelMain;
      state.speed = Math.min(SETTINGS.speedMax, state.speed + accel * dtMs);
      state.gap   = Math.max(SETTINGS.gapMin, state.gap - SETTINGS.gapShrinkPerMs * dtMs);
    }

    if (state.playing && !state.dead){
      if (p.hold){ p.vy -= state.thrust * step; addTrail(); }

      // Magnet-lite toward orbs
      for (const o of state.orbs){
        if (o.taken) continue;
        const dx = p.x - o.x, dy = p.y - o.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < 100*100){
          const pull = 0.6 * step;
          p.vy += Math.max(-0.8*step, Math.min(0.8*step, (o.y - p.y) * pull / 100));
        }
      }

      p.vy += state.gravity * step;
      p.vy = Math.max(-9, Math.min(state.maxVy, p.vy));
      p.y  += p.vy * step;
      p.targetRot = Math.max(-0.8, Math.min(0.8, (-0.6) + ((p.vy+9)/18) * (0.8 - (-0.6))));
      p.rot = p.rot + (p.targetRot - p.rot) * 0.2;

      state.spawn -= step;
      if (state.spawn <= 0) addPipe();
      for (const pipe of state.pipes) pipe.x -= state.speed * step;
      for (const orb of state.orbs)  orb.x  -= state.speed * step;

      for (const pipe of state.pipes){
        if (!pipe.passed && p.x > pipe.x + pipe.w){ pipe.passed = true; state.score++; }
        if (hitPipe(pipe)) { die(); break; }
      }
      if (!state.dead && hitBounds()) die();

      if (!state.dead){
        for (const o of state.orbs){
          if (!o.taken){
            const dx = p.x - o.x, dy = p.y - o.y;
            if (dx*dx + dy*dy < (o.r + 16)*(o.r + 16)){
              o.taken = true;
              state.score += 2;
              for (let i=0;i<12;i++){
                const life = Math.random()*12+18;
                state.particles.push({
                  type:'spark',
                  x:o.x, y:o.y,
                  vx: Math.cos(i/12*2*Math.PI)*Math.random()*2.2,
                  vy: Math.sin(i/12*2*Math.PI)*Math.random()*2.2,
                  g:0, spin:0,
                  life, maxLife: life, r: Math.random()*2+1.6, color:'#9fe9ff'
                });
              }
            }
          }
        }
      }

      while (state.pipes.length && state.pipes[0].x + state.pipes[0].w < -40) state.pipes.shift();
      while (state.orbs.length && state.orbs[0].x + 20 < -40) state.orbs.shift();

      // SIMPLE BURST trail: advect & fade
      for (const d of state.trailDots){
        d.x -= state.speed * step * 0.9;
        d.y += (Math.sin((state.t + d.seed)*0.01) * 0.25);
        d.life -= step;
      }
      while (state.trailDots.length && state.trailDots[0].life<=0) state.trailDots.shift();

      // explosion particles decay
      for (const prt of state.particles){
        prt.vy += (prt.g||0) * step;
        prt.x  += prt.vx * step;
        prt.y  += prt.vy * step;
        if (prt.type==='shard'){ prt.rot = (prt.rot||0) + (prt.spin||0); }
        prt.life -= step;
      }
      while (state.particles.length && state.particles[0].life<=0) state.particles.shift();
    }

    state.shake *= 0.9; state.flash = Math.max(0, state.flash - 0.06);
  }

  function die(){
    if (state.dead || state.deathPause) return;
    state.dead = true;
    state.playing = false;

    state.hi = Math.max(state.hi, state.score);
    try { localStorage.setItem('stary_bird_hi', String(state.hi)); } catch(e){}

    explode(p.x, p.y);

    state.deathPause = true;
    state.deathTimer = SETTINGS.respawnDelayMs;

    if (msg) msg.style.display = 'none';
  }

  function draw(){
    // clear with overscan safety (cover any subpixel transforms)
    ctx.clearRect(-2,-2,canvas.clientWidth+4, canvas.clientHeight+4);

    const sx = (Math.random()*2-1)*state.shake;
    const sy = (Math.random()*2-1)*state.shake;

    /* ===== Depthy background with golden flickers ===== */
    const W = canvas.clientWidth, H = canvas.clientHeight;
    const tbg = performance.now(); // <— monotonic timer so starfield never resets

    // Nebula washes
    {
      const g1 = ctx.createRadialGradient(W*0.15 + Math.sin(tbg*0.0002)*40, H*0.2, 0, W*0.15, H*0.2, Math.max(W,H)*0.9);
      g1.addColorStop(0.0, 'rgba(70,110,200,0.10)');
      g1.addColorStop(0.5, 'rgba(40,60,120,0.06)');
      g1.addColorStop(1.0, 'rgba(0,0,0,0)');
      ctx.fillStyle = g1; ctx.fillRect(-2,-2,W+4,H+4);

      const g2 = ctx.createRadialGradient(W*0.85 + Math.cos(tbg*0.00018)*50, H*0.75, 0, W*0.85, H*0.75, Math.max(W,H)*0.8);
      g2.addColorStop(0.0, 'rgba(120,60,140,0.08)');
      g2.addColorStop(0.6, 'rgba(50,30,70,0.05)');
      g2.addColorStop(1.0, 'rgba(0,0,0,0)');
      ctx.fillStyle = g2; ctx.fillRect(-2,-2,W+4,H+4);
    }

    // FAR layer
    ctx.globalAlpha = 0.08;
    for (let i=0;i<90;i++){
      const x = (i*120 - (tbg*0.020)%120);
      const y = 20 + (i*53) % (H-40);
      ctx.fillStyle="#bfd2ff"; ctx.fillRect(x, y, 2, 2);
    }

    // MID layer
    ctx.globalAlpha = 0.14;
    for (let i=0;i<60;i++){
      const x = (i*200 - (tbg*0.040)%200);
      const y = 12 + ((i*81) % (H-24)) + Math.sin((tbg*0.00055)+i)*2;
      ctx.fillStyle="#e7f0ff"; ctx.fillRect(x, y, 3, 3);
    }

    // GOLDEN FLICKERS
    ctx.globalAlpha = 1;
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (let i=0;i<28;i++){
      const baseX = (i*180 - (tbg*0.050)%180);
      const baseY = 30 + ((i*97) % (H-60));
      const tw = 0.45 + 0.55*(0.5 + 0.5*Math.sin(tbg*0.003 + i*12.9898));
      const a  = 0.08 + 0.28*(tw*tw);
      ctx.globalAlpha = a;
      ctx.fillStyle = "#ffd65a";
      ctx.beginPath();
      ctx.arc(baseX, baseY + Math.sin(i*3.1 + tbg*0.0012)*1.5, 1.2 + tw*0.9, 0, Math.PI*2);
      ctx.fill();
      drawGlow(ctx, baseX, baseY, 4 + tw*2.5, 0.12*a + 0.04);
    }
    ctx.restore();

    // Vignette
    ctx.globalAlpha = 0.28;
    const vgTop = ctx.createLinearGradient(0,0,0,H);
    vgTop.addColorStop(0,'rgba(0,0,0,0.45)');
    vgTop.addColorStop(0.15,'rgba(0,0,0,0.25)');
    vgTop.addColorStop(0.5,'rgba(0,0,0,0)');
    vgTop.addColorStop(0.85,'rgba(0,0,0,0.25)');
    vgTop.addColorStop(1,'rgba(0,0,0,0.45)');
    ctx.fillStyle = vgTop; ctx.fillRect(-2,-2,W+4,H+4);
    ctx.globalAlpha = 1;

    /* ===== World ===== */
    ctx.save(); ctx.translate(sx, sy);

    // SIMPLE BURST trail (expanding circles with level-scaled glow)
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (const d of state.trailDots){
      const a = Math.max(0, d.life / d.maxLife);
      if (a <= 0) continue;

      const lvlScale = 1 + (d.lvl||0) * 0.45;   // ↑ alpha & glow by level

      // radius progresses from d.w -> d.len
      const t = 1 - a;
      const r = d.w + (d.len - d.w) * t;

      // soft colored ring
      ctx.globalAlpha = 0.22 * a * lvlScale;
      ctx.beginPath();
      ctx.arc(d.x, d.y, r, 0, Math.PI*2);
      ctx.fillStyle = d.color;
      ctx.fill();

      // subtle inner core
      ctx.globalAlpha = 0.35 * a * lvlScale;
      ctx.beginPath();
      ctx.arc(d.x, d.y, r*0.45, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      ctx.fill();

      // head glow (radius & alpha scale with level)
      drawGlow(ctx, d.x, d.y, d.glow * (0.7 + 0.5*a) * (1 + (d.lvl||0)*0.45), (0.18*a + 0.06) * lvlScale);
      ctx.globalAlpha = 1;
    }
    ctx.restore();

    // Draw sleeves
    for (const pipe of state.pipes){
      const gy = currentGapY(pipe);
      const half = ((pipe.doubleGap ? (state.gap - 6) : state.gap) / 2);
      const x = pipe.x, w = pipe.w;
      const yTop = 0, hTop = gy - half;
      const yBot = gy + half, hBot = canvas.clientHeight - yBot;

      if (sleeveBodyImg.complete && sleeveCuffTop.complete && sleeveCuffBottom.complete &&
          !sleeveBodyImg._error && !sleeveCuffTop._error && !sleeveCuffBottom._error) {
        drawTopPipeSection(ctx, x, yTop, w, hTop);
        drawBottomPipeSection(ctx, x, yBot, w, hBot);
      } else {
        ctx.fillStyle = "#12324f";
        if (hTop>0) ctx.fillRect(x, yTop, w, hTop);
        if (hBot>0) ctx.fillRect(x, yBot, w, hBot);
        ctx.fillStyle = "#1a476f";
        if (hTop>0) ctx.fillRect(x, yTop+hTop-4, w, 4);
        if (hBot>0) ctx.fillRect(x, yBot, 4, 4);
      }
    }

    // Orbs (pulse scales with progression level too)
    const lvl = progressionLevel(state.score);
    const orbBase = [36, 42, 48, 58][lvl];   // bigger with progression
    const orbGlow = [0.22, 0.28, 0.34, 0.42][lvl];

    for (const o of state.orbs) {
      if (o.taken) continue;

      const pulse = 1 + 0.06 * Math.sin(state.t / 360 + o.x * 0.01);

      const glowRadius = o.r * 6 * pulse * (1 + lvl*0.15);
      const grd = ctx.createRadialGradient(o.x, o.y, 0, o.x, o.y, glowRadius);
      grd.addColorStop(0, `rgba(119,234,255,${orbGlow})`);
      grd.addColorStop(1, 'rgba(119,234,255,0)');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(o.x, o.y, glowRadius, 0, Math.PI * 2);
      ctx.fill();

      if (orbImg && orbImg.complete && !orbImg._error) {
        const drawSize = orbBase * pulse * 0.85;
        ctx.save();
        ctx.translate(o.x, o.y);
        ctx.rotate(Math.sin(state.t / 500 + o.x * 0.03) * 0.15);
        ctx.drawImage(orbImg, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
        ctx.restore();
      } else {
        ctx.beginPath();
        ctx.arc(o.x, o.y, o.r * pulse * (1 + lvl*0.2), 0, Math.PI * 2);
        ctx.fillStyle = "#77eaff";
        ctx.fill();
        ctx.strokeStyle = "#c8f3ff";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    // Explosion particles (only when you die / collect)
    for (const prt of state.particles){
      const a = prt.maxLife ? Math.max(0, prt.life / prt.maxLife) : 0;
      if (a <= 0) continue;

      if (prt.type === 'shard'){
        ctx.globalAlpha = a;
        ctx.fillStyle = prt.color;
        ctx.save();
        ctx.translate(prt.x, prt.y);
        ctx.rotate(prt.rot||0);
        ctx.fillRect(-(prt.w||6)/2, -(prt.h||3)/2, prt.w||6, prt.h||3);
        ctx.restore();
      } else {
        // small light dots
        ctx.globalAlpha = a;
        ctx.fillStyle = prt.color;
        ctx.beginPath();
        ctx.arc(prt.x, prt.y, (prt.r||2), 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    // Player (ghost)
    if (!state.dead && !state.deathPause){
      ctx.save();
      const idleOffset = (!state.playing) ? Math.sin(state.t * 0.005) * 8 : 0;
      ctx.translate(p.x, p.y + idleOffset);
      ctx.rotate(p.rot);
      const sz = 54;
      const sAmt = Math.min(0.18, Math.max(0, Math.abs(p.vy)/12 * 0.15));
      ctx.scale(1 + sAmt, 1 - sAmt);

      drawGlow(ctx, 0, 0, sz * 0.78, 0.95);

      if (ghostImg && !ghostImg._error){
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(ghostImg, -sz/2, -sz/2, sz, sz);
      } else {
        ctx.fillStyle = '#9fc2ff';
        ctx.beginPath(); ctx.arc(0,0, sz*0.45, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }

    ctx.restore();

    if (state.flash>0){
      ctx.fillStyle = `rgba(255,255,255,${state.flash*0.6})`;
      ctx.fillRect(-2,-2,canvas.clientWidth+4, canvas.clientHeight+4);
    }

    hud.textContent = `${state.score} • HI ${state.hi}`;
  }

  function loop(now){
    const frameTime = Math.min(100, now - lastTime);
    lastTime = now;
    accumulator += frameTime;

    let steps = 0;
    while (accumulator >= FIXED_DT && steps < MAX_STEPS){
      tick(FIXED_DT);
      accumulator -= FIXED_DT;
      steps++;
    }

    draw();
    requestAnimationFrame(loop);
  }

  reset();
  requestAnimationFrame(t => { lastTime = t; accumulator = 0; requestAnimationFrame(loop); });
})();
</script>
</body>
</html>
