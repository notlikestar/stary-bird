<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Stary Bird</title>
<meta name="theme-color" content="#0a0f17">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<style>
  :root { color-scheme: light dark; }
  html, body {
    margin:0; padding:0; height:100%;
    background:#07090d; color:#eaf2ff;
    font:14px/1.5 system-ui, Segoe UI, Roboto, Arial, sans-serif;
  }
  body {
    overflow:hidden; overscroll-behavior:none; touch-action:none;
    -webkit-user-select:none; -webkit-touch-callout:none;
  }

  .stage { position:fixed; inset:0; width:100vw; height:100svh; background:transparent; }
  #game  { position:absolute; left:0; top:0; width:100%; height:100%; display:block;
           background:linear-gradient(180deg,#0a1120,#0a0f17 65%, #090d14); touch-action:none; }

  .hud{
    position:absolute;
    right:calc(12px + env(safe-area-inset-right));
    top:  calc(12px + env(safe-area-inset-top));
    background:rgba(255,255,255,.08);
    padding:6px 10px; border-radius:10px;
    font-weight:800; letter-spacing:.06em; z-index:3;
  }
  .controls{
    position:absolute;
    left:calc(12px + env(safe-area-inset-left));
    top: calc(12px + env(safe-area-inset-top));
    opacity:.6; font-weight:700; color:#c9d8ff; z-index:2;
  }

  .center{ position:absolute; inset:0; display:grid; place-items:center;
           pointer-events:none; font-weight:900; letter-spacing:.08em;
           color:#9fb7ff99; text-align:center; padding:0 10px; z-index:1; }
</style>
</head>
<body>
  <div class="stage">
    <canvas id="game"></canvas>
    <div class="hud" id="hud">0 • HI 0</div>
    <div class="controls">SPACE / TAP</div>
    <div class="center" id="msg">TAP / SPACE TO START</div>
  </div>

<script>
(() => {
  'use strict';

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: true });
  const hud = document.getElementById('hud');
  const msg = document.getElementById('msg');

  /* ---------- Robust sizing for iPhone landscape ---------- */
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function sizeToViewport() {
    const vv = window.visualViewport;
    const w = Math.floor(vv ? vv.width  : window.innerWidth);
    const h = Math.floor(vv ? vv.height : window.innerHeight);
    canvas.style.width  = w + 'px';
    canvas.style.height = h + 'px';
    const cw = Math.max(1, Math.floor(w * DPR));
    const ch = Math.max(1, Math.floor(h * DPR));
    canvas.width = cw; canvas.height = ch;
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  new ResizeObserver(() => { DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1)); sizeToViewport(); }).observe(document.body);
  window.addEventListener('orientationchange', () => setTimeout(sizeToViewport, 150), {passive:true});
  if (window.visualViewport) window.visualViewport.addEventListener('resize', sizeToViewport, {passive:true});
  sizeToViewport();

  // Prevent double-tap zoom on iOS
  let lastTouchEnd = 0;
  document.addEventListener('touchend', e => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = now;
  }, {passive:false});

  /* ----------------------- Logo (player graphic) ----------------------- */
  const logoImg = new Image();
  logoImg.decoding = 'async';
  logoImg.loading = 'eager';
  logoImg.crossOrigin = 'anonymous';
  logoImg.src = 'assets/logo.png';
  let logoReady = false;
  logoImg.onload = () => { logoReady = true; };

  /* ----------------------- Helpers ----------------------- */
  const rand  = (a,b)=> Math.random()*(b-a)+a;
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const lerp  = (a,b,t)=> a + (b-a)*t;
  const lerpColor = (c1, c2, t) => {
    const p = (c)=>[parseInt(c.slice(1,3),16),parseInt(c.slice(3,5),16),parseInt(c.slice(5,7),16)];
    const [r1,g1,b1]=p(c1), [r2,g2,b2]=p(c2);
    const r=Math.round(lerp(r1,r2,t)), g=Math.round(lerp(g1,g2,t)), b=Math.round(lerp(b1,b2,t));
    return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
  };

  /* ----------------------- Game State ----------------------- */
  const state = {
    playing:false, dead:false, score:0, hi:Number(localStorage.getItem('stary_bird_hi')||0),
    t:0, shake:0, flash:0,
    gravity:0.33, thrust:0.6, maxVy:9,
    speed:4.2, gap:150,
    spawn:0, minSpawnFrames:110, maxSpawnFrames:170,
    maxSlopePxPerFrame:2.4, lastGapY:null, lastPipeX:null,
    orbs:[], pipes:[], particles:[],
    trailBase:'#cfe3ff', trailBlue:'#4ab7ff', trailGold:'#ffd54a',
    startTime:0 // for micro-acceleration window
  };

  const p = { x:180, y:canvas.clientHeight/2, vy:0, rot:0, targetRot:0, hold:false, w:60, h:60 };

  /* ----------------------- Input ----------------------- */
  function startIfNeeded(){
    if (!state.playing && !state.dead){
      start();
    } else if (state.dead){
      restart();
    }
  }
  window.addEventListener('keydown', e => {
    if (['Space','ArrowUp','KeyW','Enter'].includes(e.code)) {
      e.preventDefault(); p.hold = true; startIfNeeded();
    }
  }, {passive:false});
  window.addEventListener('keyup', e => {
    if (['Space','ArrowUp','KeyW','Enter'].includes(e.code)) {
      e.preventDefault(); p.hold = false; if (state.dead) restart();
    }
  }, {passive:false});
  canvas.addEventListener('touchstart', e => { e.preventDefault(); p.hold = true; startIfNeeded(); }, {passive:false});
  canvas.addEventListener('touchend',   e => { e.preventDefault(); p.hold = false; if (state.dead) restart(); }, {passive:false});

  /* ----------------------- World ----------------------- */
  function addPipe(){
    const h = canvas.clientHeight, margin = 60;
    const baseMin = state.minSpawnFrames * (4.2/state.speed);
    const baseMax = state.maxSpawnFrames * (4.2/state.speed);
    state.spawn = Math.floor(rand(baseMin, baseMax));
    const dx = state.spawn * state.speed;

    const mid = h/2;
    const prev = state.lastGapY ?? mid;
    const maxDeltaByTime = dx * (state.maxSlopePxPerFrame / state.speed);
    const allowedDelta = Math.min(maxDeltaByTime, 180);

    let proposed = prev + rand(-allowedDelta, +allowedDelta);
    const safeTop = margin + state.gap/2;
    const safeBot = h - margin - state.gap/2;
    proposed = clamp(proposed, safeTop, safeBot);

    const wobble = rand(-12, 12);
    const gapY = clamp(proposed + wobble, safeTop, safeBot);
    const w = 70;

    // Decide pattern: moving gate or double pipes
    const isMoving = Math.random() < 0.18;
    const isDouble = !isMoving && Math.random() < 0.12;

    // Primary pipe
    state.pipes.push({
      x: canvas.clientWidth + 40,
      baseGapY: gapY,
      w,
      passed:false,
      type: isMoving ? 'moving' : 'normal',
      amp: isMoving ? rand(16, 34) : 0,
      speed: isMoving ? rand(0.8, 1.3) : 0,
      phase: Math.random()*Math.PI*2
    });

    // Optional double: quick follow-up pipe with slightly smaller gap
    if (isDouble){
      state.pipes.push({
        x: canvas.clientWidth + 40 + w + 100,
        baseGapY: clamp(gapY + rand(-30, 30), safeTop, safeBot),
        w,
        passed:false,
        type:'normal',
        amp:0, speed:0, phase:0,
        doubleGap:true // render with slightly tighter gap
      });
    }

    state.lastGapY = gapY;
    state.lastPipeX = canvas.clientWidth + 40;

    // orb near the center of the gap
    if (Math.random() < 0.55){
      state.orbs.push({ x: canvas.clientWidth + 40 + w/2, y: gapY, r:8, taken:false, t0: state.t });
    }
  }

  const currentGapY = (pipe) => {
    if (pipe.type === 'moving'){
      return pipe.baseGapY + Math.sin(pipe.phase + state.t/1000 * pipe.speed)*pipe.amp;
    }
    return pipe.baseGapY;
  };

  /* ----------------------- Flow ----------------------- */
  function reset(){
    state.playing=false; state.dead=false; state.score=0;
    state.speed=4.2; state.gap=150; state.gravity=0.33; state.thrust=0.6;
    state.pipes.length=0; state.orbs.length=0; state.particles.length=0;
    state.spawn=30; state.t=0; state.shake=0; state.flash=0;
    state.lastGapY = canvas.clientHeight/2; state.lastPipeX = canvas.clientWidth;
    p.x=180; p.y=canvas.clientHeight/2; p.vy=0; p.rot=0; p.targetRot=0; p.hold=false;

    if (msg) { msg.textContent = 'TAP / SPACE TO START'; msg.style.display=''; }
  }
  function start(){
    if (state.dead) return;
    state.playing=true;
    state.startTime = performance.now();
    if (msg) msg.style.display = 'none';
  }
  function restart(){ reset(); start(); }

  /* ----------------------- Particles ----------------------- */
  function addTrail(){
    // Trail color: base <10, blend 10–25 (blue→gold), gold >=25
    let c = state.trailBase;
    if (state.score >= 25) c = state.trailGold;
    else if (state.score >= 10) {
      const t = clamp((state.score - 10) / 15, 0, 1);
      c = lerpColor(state.trailBlue, state.trailGold, t);
    }

    for (let i=0;i<3;i++){
      const life = Math.random()*14+24;
      state.particles.push({
        x: p.x - 26 + Math.random()*10,
        y: p.y + Math.random()*10 - 5,
        vx: -state.speed*0.6 + (Math.random()*-0.6),
        vy: (Math.random()-.5)*1.3,
        life,
        maxLife: life,
        r: Math.random()*2+2,
        color: c
      });
    }
  }

  /* ----------------------- Collisions ----------------------- */
  function hitPipe(pipe){
    const gy = currentGapY(pipe);
    const half = (pipe.doubleGap ? (state.gap - 14) : state.gap) / 2;
    if (p.x + p.w*0.35 > pipe.x && p.x - p.w*0.35 < pipe.x + pipe.w){
      if (p.y - p.h*0.35 < gy - half || p.y + p.h*0.35 > gy + half) return true;
    }
    return false;
  }
  function hitBounds(){ return (p.y < 0) || (p.y > canvas.clientHeight); }

  /* ----------------------- Loop ----------------------- */
  let last = performance.now();
  function loop(t){
    const dt = Math.min(32, t - last); last = t;
    const dtNorm = dt / 16.67; // normalize to ~60fps
    state.t += dt;

    // Micro-acceleration (ease-in) for first 3 seconds after start
    if (state.playing && !state.dead){
      const sinceStart = Math.max(0, t - state.startTime);
      if (sinceStart < 3000) {
        state.speed = Math.min(9.5, state.speed + 0.0003 * dt); // gentle ease
      } else {
        state.speed = Math.min(9.5, state.speed + 0.0008 * dt);
      }
      state.gap   = Math.max(118, state.gap - 0.0035 * dt);
    }

    if (state.playing && !state.dead){
      if (p.hold){ p.vy -= state.thrust; addTrail(); }
      // Orb magnetism (vertical only)
      for (const o of state.orbs){
        if (o.taken) continue;
        const dx = p.x - o.x, dy = p.y - o.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < 100*100){
          const pull = 0.010 * dtNorm; // gentle pull
          p.vy += clamp((o.y - p.y) * pull / 100, -0.8, 0.8);
        }
      }

      p.vy += state.gravity; p.vy = clamp(p.vy, -9, state.maxVy); p.y += p.vy;
      p.targetRot = clamp(lerp(-0.6, 0.8, (p.vy+9)/18), -0.8, 0.8); p.rot = lerp(p.rot, p.targetRot, 0.2);

      state.spawn -= 1; if (state.spawn <= 0) addPipe();

      for (const pipe of state.pipes) pipe.x -= state.speed;
      for (const orb of state.orbs)  orb.x  -= state.speed;

      for (const pipe of state.pipes){
        if (!pipe.passed && p.x > pipe.x + pipe.w){
          pipe.passed = true; state.score++;
        }
        if (hitPipe(pipe)) die();
      }
      if (hitBounds()) die();

      for (const o of state.orbs){
        if (!o.taken){
          const dx = p.x - o.x, dy = p.y - o.y;
          if (dx*dx + dy*dy < (o.r + 16)*(o.r + 16)){
            o.taken = true; state.score += 2;
            for (let i=0;i<12;i++){
              const life = Math.random()*12+18;
              state.particles.push({
                x:o.x, y:o.y,
                vx: Math.cos(i/12*2*Math.PI)*Math.random()*2.2,
                vy: Math.sin(i/12*2*Math.PI)*Math.random()*2.2,
                life, maxLife: life, r: Math.random()*2+1.6, color:'#9fe9ff'
              });
            }
          }
        }
      }

      while (state.pipes.length && state.pipes[0].x + state.pipes[0].w < -40) state.pipes.shift();
      while (state.orbs.length && state.orbs[0].x + 20 < -40) state.orbs.shift();

      for (const prt of state.particles){ prt.x += prt.vx; prt.y += prt.vy; prt.life--; }
      while (state.particles.length && state.particles[0].life<=0) state.particles.shift();
    }

    state.shake *= 0.9; state.flash = Math.max(0, state.flash - 0.06);
    draw();
    requestAnimationFrame(loop);
  }

  /* ----------------------- Death ----------------------- */
  function die(){
    if (state.dead) return;
    state.dead = true; state.playing = false;
    state.shake = 12; state.flash = 0.8; p.hold = false;
    state.hi = Math.max(state.hi, state.score);
    try { localStorage.setItem('stary_bird_hi', String(state.hi)); } catch(e){}
    if (msg) { msg.textContent = 'TAP / SPACE TO RESTART'; msg.style.display = ''; }
  }

  /* ----------------------- Render ----------------------- */
  function draw(){
    const sx = (Math.random()*2-1)*state.shake;
    const sy = (Math.random()*2-1)*state.shake;

    ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

    // Parallax starfield (two layers)
    // Layer A (far)
    ctx.globalAlpha = 0.06;
    for (let i=0;i<70;i++){
      const x = (i*130 - (state.t*0.035)%130);
      const y = 30 + (i*47) % (canvas.clientHeight-60);
      ctx.fillStyle="#bcd1ff"; ctx.fillRect(x, y, 2, 2);
    }
    // Layer B (nearer, slower vertical drift, slightly larger)
    ctx.globalAlpha = 0.12;
    for (let i=0;i<40;i++){
      const x = (i*220 - (state.t*0.06)%220);
      const y = 20 + ((i*83) % (canvas.clientHeight-40)) + Math.sin((state.t*0.0006)+i)*2;
      ctx.fillStyle="#e7f0ff"; ctx.fillRect(x, y, 3, 3);
    }
    ctx.globalAlpha = 1;

    ctx.save(); ctx.translate(sx, sy);

    // pipes
    for (const pipe of state.pipes){
      const gy = currentGapY(pipe);
      const half = (pipe.doubleGap ? (state.gap - 14) : state.gap) / 2;
      const x = pipe.x, w = pipe.w;
      const yTop = 0, hTop = gy - half;
      const yBot = gy + half, hBot = canvas.clientHeight - yBot;
      ctx.fillStyle = "#12324f";
      if (hTop>0) ctx.fillRect(x, yTop, w, hTop);
      if (hBot>0) ctx.fillRect(x, yBot, w, hBot);
      ctx.fillStyle = "#1a476f";
      if (hTop>0) ctx.fillRect(x, yTop+hTop-4, w, 4);
      if (hBot>0) ctx.fillRect(x, yBot, 4, 4);
    }

    // orbs (glow pulse + core)
    for (const o of state.orbs){
      if (o.taken) continue;
      const pulse = 1 + 0.18*Math.sin(state.t/120 + o.x*0.02);
      // glow
      const grd = ctx.createRadialGradient(o.x, o.y, 0, o.x, o.y, o.r*6*pulse);
      grd.addColorStop(0, 'rgba(119,234,255,0.35)');
      grd.addColorStop(1, 'rgba(119,234,255,0)');
      ctx.fillStyle = grd;
      ctx.beginPath(); ctx.arc(o.x, o.y, o.r*6*pulse, 0, Math.PI*2); ctx.fill();

      // core
      ctx.beginPath(); ctx.arc(o.x, o.y, o.r*pulse, 0, Math.PI*2);
      ctx.fillStyle = "#77eaff"; ctx.fill();
      ctx.strokeStyle = "#c8f3ff"; ctx.lineWidth = 2; ctx.stroke();
    }

    // particles (fade using life/maxLife)
    for (const prt of state.particles){
      const a = prt.maxLife ? Math.max(0, prt.life / prt.maxLife) : 0;
      if (a <= 0) continue;
      ctx.globalAlpha = a;
      ctx.fillStyle = prt.color;
      ctx.beginPath(); ctx.arc(prt.x, prt.y, prt.r, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;

    // player — logo with subtle glow, squash/stretch by vertical speed
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rot);
    const sz = 54;
    const sAmt = clamp(Math.abs(p.vy)/12 * 0.15, 0, 0.18); // stretch amount
    ctx.scale(1 + sAmt, 1 - sAmt);

    // soft glow
    ctx.globalAlpha = 0.25;
    ctx.filter = 'blur(4px)';
    ctx.fillStyle = '#ffffff';
    ctx.beginPath(); ctx.ellipse(0, 0, sz*0.45, sz*0.45, 0, 0, Math.PI*2); ctx.fill();
    ctx.filter = 'none'; ctx.globalAlpha = 1;

    if (logoReady){
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(logoImg, -sz/2, -sz/2, sz, sz);
    } else {
      // fallback diamond
      ctx.fillStyle = '#9fc2ff';
      ctx.beginPath();
      ctx.moveTo(0,-sz*0.45); ctx.lineTo(sz*0.45,0); ctx.lineTo(0,sz*0.45); ctx.lineTo(-sz*0.45,0); ctx.closePath();
      ctx.fill();
    }
    ctx.restore();

    ctx.restore();

    if (state.flash>0){
      ctx.fillStyle = `rgba(255,255,255,${state.flash*0.6})`;
      ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
    }

    // HUD
    hud.textContent = `${state.score} • HI ${state.hi}`;
  }

  /* ----------------------- Boot ----------------------- */
  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
