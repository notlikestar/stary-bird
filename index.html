<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Stary Bird</title>
<meta name="theme-color" content="#0a0f17">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<style>
  :root { color-scheme: light dark; }

  /* Page & scrolling guards */
  html, body {
    margin:0; padding:0; height:100%;
    background:#07090d; color:#eaf2ff;
    font:14px/1.5 system-ui,Segoe UI,Roboto,Arial,sans-serif;
  }
  body {
    overflow:hidden;               /* no scroll */
    overscroll-behavior:none;
    touch-action:none;             /* block page gestures during play */
    -webkit-user-select:none;
    -webkit-touch-callout:none;
  }

  /* Full-bleed stage: NO safe-area padding here (prevents left gap) */
  .stage{
    position:fixed;
    inset:0;                       /* edge-to-edge */
    width:100vw;
    height:100svh;                 /* visible viewport height (iOS-safe) */
    display:block;
    background:transparent;
  }

  /* Canvas fills the stage exactly and is anchored left/top */
  #game{
    position:absolute; left:0; top:0;
    display:block; width:100%; height:100%;
    background:linear-gradient(180deg,#0a1120,#0a0f17 65%, #090d14);
    touch-action:none;
  }

  /* UI overlays respect the notch (safe areas) */
  .hud{
    position:absolute;
    right:calc(12px + env(safe-area-inset-right));
    top:calc(12px + env(safe-area-inset-top));
    background:rgba(255,255,255,.06);
    padding:6px 10px; border-radius:10px;
    font-weight:800; letter-spacing:.06em;
    z-index:2;
  }
  .controls{
    position:absolute;
    left:calc(12px + env(safe-area-inset-left));
    top:calc(12px + env(safe-area-inset-top));
    opacity:.6; font-weight:700; color:#c9d8ff; z-index:2;
  }
  .center{
    position:absolute; inset:0; display:grid; place-items:center;
    pointer-events:none; font-weight:900; letter-spacing:.08em;
    color:#9fb7ff99; text-align:center; padding:0 10px; z-index:1;
  }
</style>
</head>
<body>
  <div class="stage">
    <canvas id="game"></canvas>
    <div class="hud" id="hud">0 â€¢ HI 0</div>
    <div class="controls">SPACE / TAP</div>
    <div class="center" id="msg">PRESS SPACE / TAP</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');
  const msg = document.getElementById('msg');

  /* ---- iPhone landscape sizing: always match the *visible* viewport ---- */
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  function sizeToVisualViewport() {
    const vv = window.visualViewport;
    const w  = vv ? Math.floor(vv.width)  : window.innerWidth;
    const h  = vv ? Math.floor(vv.height) : window.innerHeight;

    // Ensure CSS box matches exactly (prevents subpixel scroll/gap)
    canvas.style.width  = w + 'px';
    canvas.style.height = h + 'px';

    // Backing store at DPR
    const cw = Math.max(1, Math.floor(w * DPR));
    const ch = Math.max(1, Math.floor(h * DPR));
    canvas.width = cw;
    canvas.height = ch;
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }

  new ResizeObserver(() => {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    sizeToVisualViewport();
  }).observe(document.body);

  window.addEventListener('orientationchange', () => setTimeout(sizeToVisualViewport, 150), {passive:true});
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', sizeToVisualViewport, {passive:true});
  }
  sizeToVisualViewport();

  // prevent double-tap zoom on iOS
  let lastTouchEnd = 0;
  document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault();
    lastTouchEnd = now;
  }, {passive:false});

  /* ---------------------- Game State ---------------------- */

  const state = {
    playing: false, dead: false, score: 0, hi: Number(localStorage.getItem('stary_bird_hi')||0),
    t: 0, shake: 0, flash: 0,
    gravity: 0.33, thrust: 0.6, maxVy: 9,
    speed: 4.2, gap: 150,
    spawn: 0,
    minSpawnFrames: 110,
    maxSpawnFrames: 170,
    maxSlopePxPerFrame: 2.4,
    lastGapY: null,
    lastPipeX: null,
    orbs: [],
    pipes: [],
    particles: [],

    /* ðŸ”¥ Cosmetic state */
    trailColor: '#cfe3ff',                 // default pale blue-white
    unlocked: { blue:false, gold:false, crown:false },
    crownActive: false,
    effectTimer: 0,                        // announcement timer (frames)
    announce: ''                           // announcement string
  };

  // Player
  const p = { x: 180, y: canvas.clientHeight/2, vy: 0, rot: 0, targetRot: 0, hold: false, w: 60, h: 60 };

  // Optional logo (fallback circle if not present)
  const logo = new Image();
  logo.src = "./assets/logo.png";
  let logoReady = false;
  logo.onload = ()=>{ logoReady = true; };

  /* ---------------------- Input ---------------------- */
  function startIfNeeded(){ if (!state.playing) start(); }
  addEventListener('keydown', e=>{
    if (['Space','ArrowUp','KeyW'].includes(e.code)) { e.preventDefault(); p.hold = true; startIfNeeded(); }
  }, {passive:false});
  addEventListener('keyup', e=>{
    if (['Space','ArrowUp','KeyW'].includes(e.code)) { e.preventDefault(); p.hold = false; if (state.dead) restart(); }
  }, {passive:false});
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); p.hold = true; startIfNeeded(); }, {passive:false});
  canvas.addEventListener('touchend', e=>{ e.preventDefault(); p.hold = false; if (state.dead) restart(); }, {passive:false});

  /* ---------------------- Utils ---------------------- */
  const rand  = (a,b)=> Math.random()*(b-a)+a;
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const lerp  = (a,b,t)=> a + (b-a)*t;

  /* ---------------------- World Gen ---------------------- */
  function addPipe(){
    const h = canvas.clientHeight;
    const margin = 60;
    const baseMin = state.minSpawnFrames * (4.2/state.speed);
    const baseMax = state.maxSpawnFrames * (4.2/state.speed);
    state.spawn = Math.floor(rand(baseMin, baseMax));
    const dx = state.spawn * state.speed;

    const mid = h/2;
    const prev = state.lastGapY ?? mid;
    const maxDeltaByTime = dx * (state.maxSlopePxPerFrame / state.speed);
    const hardCap = 180;
    const allowedDelta = Math.min(maxDeltaByTime, hardCap);

    let proposed = prev + rand(-allowedDelta, +allowedDelta);
    const safeTop = margin + state.gap/2;
    const safeBot = h - margin - state.gap/2;
    proposed = clamp(proposed, safeTop, safeBot);

    const wobble = rand(-12, 12);
    const gapY = clamp(proposed + wobble, safeTop, safeBot);
    const w = 70;

    state.pipes.push({x: canvas.clientWidth + 40, gapY, w, passed:false});
    state.lastGapY = gapY;
    state.lastPipeX = canvas.clientWidth + 40;

    // bonus orb sometimes
    if (Math.random()<0.55){
      state.orbs.push({x: canvas.clientWidth + 40 + w/2, y: gapY, r: 8, taken:false});
    }
  }

  /* ---------------------- Cosmetics ---------------------- */
  function announce(text) {
    state.announce = text;
    state.effectTimer = 180; // ~3s at 60fps
  }
  function triggerCrownEffect() {
    // radial gold starburst
    for (let i = 0; i < 90; i++) {
      state.particles.push({
        x: p.x, y: p.y,
        vx: Math.cos(i/90 * 2*Math.PI) * (Math.random()*3 + 1.2),
        vy: Math.sin(i/90 * 2*Math.PI) * (Math.random()*3 + 1.2),
        r: 2 + Math.random()*2,
        life: 60 + Math.random()*24,
        color: '#ffd54a'
      });
    }
  }
  function checkMilestones() {
    if (state.score >= 10 && !state.unlocked.blue) {
      state.unlocked.blue = true;
      state.trailColor = '#4ab7ff'; // blue
      announce('ðŸ”¥ BLUE FLAME UNLOCKED!');
    }
    if (state.score >= 25 && !state.unlocked.gold) {
      state.unlocked.gold = true;
      state.trailColor = '#ffd54a'; // gold
      announce('âœ¨ GOLD TRAIL UNLOCKED!');
    }
    if (state.score >= 50 && !state.unlocked.crown) {
      state.unlocked.crown = true;
      state.trailColor = '#ffd54a'; // keep gold
      state.crownActive = true;
      announce('ðŸ‘‘ CROWN MODE UNLOCKED!');
      triggerCrownEffect();
    }
  }

  /* ---------------------- Game Flow ---------------------- */
  function reset(){
    state.playing = false; state.dead = false; state.score = 0;
    state.speed = 4.2; state.gap = 150; state.gravity = 0.33; state.thrust = 0.6;
    state.pipes.length = 0; state.orbs.length = 0; state.particles.length = 0;
    state.spawn = 30; state.t = 0; state.shake=0; state.flash=0;
    state.lastGapY = canvas.clientHeight/2;
    state.lastPipeX = canvas.clientWidth;
    p.x = 180; p.y = canvas.clientHeight/2; p.vy = 0; p.rot = 0; p.targetRot = 0; p.hold = false;

    // reset cosmetics for a fresh run (progress per-run; persist if you want)
    state.trailColor = '#cfe3ff';
    state.unlocked = { blue:false, gold:false, crown:false };
    state.crownActive = false;
    state.effectTimer = 0; state.announce = '';

    msg.textContent = 'PRESS SPACE / TAP';
  }
  function start(){ if (state.dead) return; state.playing = true; msg.textContent = ''; }
  function restart(){ reset(); start(); }

  /* ---------------------- Particles ---------------------- */
  function addTrail() {
    // flame/spark particles behind player using current trailColor
    for (let i=0;i<3;i++){
      state.particles.push({
        x: p.x - 26 + Math.random()*10,
        y: p.y + Math.random()*10 - 5,
        vx: -state.speed*0.6 + (Math.random()*-0.6),
        vy: (Math.random()-.5)*1.3,
        life: rand(18,32),
        r: rand(2,4),
        color: state.trailColor
      });
    }
  }

  /* ---------------------- Collisions ---------------------- */
  function hitPipe(pipe){
    const half = state.gap/2;
    if (p.x + p.w*0.35 > pipe.x && p.x - p.w*0.35 < pipe.x + pipe.w){
      if (p.y - p.h*0.35 < pipe.gapY - half || p.y + p.h*0.35 > pipe.gapY + half) return true;
    }
    return false;
  }
  function hitBounds(){ return (p.y < 0) || (p.y > canvas.clientHeight); }

  /* ---------------------- Loop ---------------------- */
  let last = performance.now();
  function loop(t){
    const dt = Math.min(32, t - last); last = t;
    state.t += dt;

    if (state.playing && !state.dead){
      state.speed = Math.min(9.5, state.speed + 0.0008*dt);
      state.gap   = Math.max(118, state.gap   - 0.0035*dt);
    }

    if (state.playing && !state.dead){
      if (p.hold){ p.vy -= state.thrust; addTrail(); }
      p.vy += state.gravity;
      p.vy = clamp(p.vy, -9, state.maxVy);
      p.y += p.vy;

      p.targetRot = clamp(lerp(-0.6, 0.8, (p.vy+9)/18), -0.8, 0.8);
      p.rot = lerp(p.rot, p.targetRot, 0.2);

      state.spawn -= 1;
      if (state.spawn <= 0) addPipe();

      for (const pipe of state.pipes) pipe.x -= state.speed;
      for (const orb of state.orbs)  orb.x  -= state.speed;

      for (const pipe of state.pipes){
        if (!pipe.passed && p.x > pipe.x + pipe.w){
          pipe.passed = true; state.score++;
          checkMilestones();
        }
        if (hitPipe(pipe)) die();
      }
      if (hitBounds()) die();

      for (const o of state.orbs){
        if (!o.taken){
          const dx = p.x - o.x, dy = p.y - o.y;
          if (dx*dx + dy*dy < (o.r + 16)*(o.r + 16)){
            o.taken = true; state.score += 2;
            state.shake = Math.max(state.shake, 6);
            checkMilestones();
            for (let i=0;i<12;i++){
              state.particles.push({
                x:o.x, y:o.y, vx: Math.cos(i/12*2*Math.PI)*rand(0.5,2.2),
                vy: Math.sin(i/12*2*Math.PI)*rand(0.5,2.2), life: rand(14,26),
                r: rand(1.5,3.5), color:'#9fe9ff'
              });
            }
          }
        }
      }

      while (state.pipes.length && state.pipes[0].x + state.pipes[0].w < -40) state.pipes.shift();
      while (state.orbs.length && state.orbs[0].x + 20 < -40) state.orbs.shift();

      for (const prt of state.particles){ prt.x += prt.vx; prt.y += prt.vy; prt.life--; }
      while (state.particles.length && state.particles[0].life<=0) state.particles.shift();
    } else {
      p.y += Math.sin(state.t/400)*0.3;
      p.rot = Math.sin(state.t/600)*0.1;
    }

    state.shake *= 0.9; state.flash = Math.max(0, state.flash - 0.06);
    draw();
    requestAnimationFrame(loop);
  }

  /* ---------------------- Death ---------------------- */
  function die(){
    if (state.dead) return;
    state.dead = true; state.playing = false;
    state.shake = 12; state.flash = 0.8;
    p.hold = false;
    state.hi = Math.max(state.hi, state.score);
    localStorage.setItem('stary_bird_hi', String(state.hi));
    msg.textContent = 'GAME OVER â€” PRESS SPACE / TAP';
  }

  /* ---------------------- Render ---------------------- */
  function draw(){
    const sx = (Math.random()*2-1)*state.shake;
    const sy = (Math.random()*2-1)*state.shake;

    ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

    // stars bg
    ctx.globalAlpha = 0.08;
    for (let i=0;i<60;i++){
      const x = (i*140 - (state.t*0.05)%140);
      const y = 40 + (i*53)% (canvas.clientHeight-80);
      ctx.fillStyle="#bcd1ff";
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;

    ctx.save();
    ctx.translate(sx, sy);

    // pipes
    for (const pipe of state.pipes){
      const half = state.gap/2;
      const x = pipe.x, w = pipe.w, yTop = 0, hTop = pipe.gapY - half, yBot = pipe.gapY + half, hBot = canvas.clientHeight - yBot;
      ctx.fillStyle = "#12324f";
      ctx.fillRect(x, yTop, w, hTop);
      ctx.fillRect(x, yBot, w, hBot);
      ctx.fillStyle = "#1a476f";
      ctx.fillRect(x, yTop+hTop-4, w, 4);
      ctx.fillRect(x, yBot, w, 4);
    }

    // orbs
    for (const o of state.orbs){
      if (o.taken) continue;
      const pulse = 1 + 0.15*Math.sin(state.t/120 + o.x*0.02);
      ctx.beginPath();
      ctx.arc(o.x, o.y, o.r*pulse, 0, Math.PI*2);
      ctx.fillStyle = "#77eaff";
      ctx.fill();
      ctx.strokeStyle = "#c8f3ff";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // particles (trail + effects)
    ctx.save();
    for (const prt of state.particles){
      const a = Math.max(0, prt.life/28);
      ctx.globalAlpha = a;
      ctx.fillStyle = prt.color || state.trailColor;
      ctx.beginPath(); ctx.arc(prt.x, prt.y, prt.r, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
    ctx.globalAlpha = 1;

    // player
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rot);
    const sz = 54;

    // crown (if active) â€” draw above the ship
    if (state.crownActive){
      ctx.save();
      ctx.translate(0, -sz*0.75);
      drawCrown(ctx, 18);
      ctx.restore();
    }

    if (logoReady){
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,.35)";
      ctx.shadowBlur = 18;
      roundImage(logo, -sz/2, -sz/2, sz, sz, 10);
      ctx.restore();
    } else {
      ctx.fillStyle = "#6aa0ff"; ctx.beginPath(); ctx.arc(0,0, sz*0.45, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = "#fff"; ctx.font="bold 12px system-ui"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText("STAR",0,0);
    }

    ctx.restore(); // player

    ctx.restore(); // shake transform

    // screen flash
    if (state.flash>0){
      ctx.fillStyle = `rgba(255,255,255,${state.flash*0.6})`;
      ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
    }

    // Announcement text
    if (state.effectTimer > 0 && state.announce) {
      state.effectTimer--;
      ctx.save();
      const alpha = Math.min(1, state.effectTimer / 60);
      ctx.globalAlpha = alpha;
      ctx.font = 'bold 22px system-ui';
      ctx.fillStyle = 'white';
      ctx.textAlign = 'center';
      ctx.fillText(state.announce, canvas.clientWidth / 2, canvas.clientHeight * 0.15);
      ctx.restore();
    }

    // HUD
    hud.textContent = `${state.score} â€¢ HI ${state.hi}`;
  }

  function drawCrown(ctx, r){
    ctx.save();
    // base
    ctx.fillStyle = '#ffd54a';
    ctx.strokeStyle = '#b78900';
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.moveTo(-r, 6);
    ctx.lineTo(-r*0.6, -2);
    ctx.lineTo(-r*0.2, 6);
    ctx.lineTo(r*0.2, -2);
    ctx.lineTo(r*0.6, 6);
    ctx.lineTo(r, -2);
    ctx.lineTo(r, 6);
    ctx.lineTo(-r, 6);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    // jewels
    ctx.fillStyle = '#fff3a1';
    for (let i=-2;i<=2;i++){
      ctx.beginPath();
      ctx.arc(i* r*0.25, 2, 2.2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function roundImage(img, x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    ctx.save(); ctx.clip(); ctx.drawImage(img, x, y, w, h); ctx.restore();
    ctx.strokeStyle = "rgba(255,255,255,.15)";
    ctx.lineWidth = 2; ctx.stroke();
  }

  /* ---------------------- Boot ---------------------- */
  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
